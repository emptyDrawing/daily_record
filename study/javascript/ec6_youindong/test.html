<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Document</title>
</head>
<body>
<script> const log = console.log; </script>

## 명령형코드
<script type="module">
// 리스트에서 홀수를 length 만큼 뽑아서 제곱한 후 모두 더하기
//function f (list, length) {
//    let i = 0;
//    let acc = 0;
//    
//    for ( const a of list ) {
//        if( a % 2 ) {
//          acc += a * a ;
//        }
//        if( ++i == length) break;
//    }
//    
//    log(acc);
//}
//
//
//function main() {
//    // f([1, 2, 3, 4, 5], 1);
//    // f([1, 2, 3, 4, 5], 2);
//    // f([1, 2, 3, 4, 5], 3);
//}
//
//main();
    
</script>

## 함수형 코드

<script>
const curry = f => (a, ...bs) =>
bs.length ? f(a, ...bs) : (...bs) => f(a, ...bs); 


const L = {};

// 제너레이터 *
L.range = function *(stop){
    
    let i = -1;
    while( ++i < stop ) { console.log("range"); yield i } ;
}


L.filter = curry(function *(f, iter){
    for ( const a of iter ) {
       if( f(a) ) yield a;
    }
})

L.map = curry(function *(f, iter){
    for ( const a of iter ) {
        yield f(a);
    }
});

// 명령은 선언한다.
const take = curry(function(length, iter) {
    let res = [];
    for ( const a of iter) {
        res.push(a);
        if(res.length == length) return res;
    }
})

const reduce = curry(function(f, acc, iter) {
    if ( arguments.length === 2) {
        iter = acc[Symbol.iterator]();
        acc = iter.next().value;
    }

    for ( const a of iter) {
        acc = f(acc,  a);
    }
    return acc;
})

const add = curry((a, b) => a + b); 

// 함수도 축약 가능하다.
const go = (...fs) => reduce(
    (a, f) => f(a), fs
)



// 읽는 법은 맨 오른쪽 부터 왼쪽으로
const f = (list, length) =>
    reduce( add, 0, 
        take( length, 
            L.map( a => a * a , 
                L.filter( a => a % 2, list ))));


// go를 활용해서
const f2 = (list, length ) =>
    go(
        list,
        list => L.filter( a => a % 2, list ),
        list => L.map( a => a * a, list),
        list => take( length, list),
        list => reduce( add , 0, list)
    )
    
// go, curry 를 활용해서
const f3 = (list, length ) =>
go(
    list,
    list => L.filter( a => a % 2)(list),
    list => L.map( a => a * a)(list),
    list => take( length)(list),
    list => reduce(add)(list)
)

// go, curry 를 활용해서
const f4 = (list, length) =>
go(
    list,
    L.filter(a => a % 2),
    L.map(a => a * a),
    take(length),
    reduce(add),
)


function main() {
    log( f([1, 2, 3, 4, 5], 2) );
    log( f2([1, 2, 3, 4, 5], 2) );
    log( f3([1, 2, 3, 4, 5], 2) );
    log( f4([1, 2, 3, 4, 5], 2) );
    log( f2(L.range(Infinity), 5));
}

main();

</script>


### 2차원 배열

<script>
console.clear();

const arr = [
    [1, 2],
    [3, 4, 5],
    [6, 7, 8],
    [9, 10],
];

// 순회만 하고 위임하면 됨.
L.flat = function *(iter) {
    for ( const a of iter) {
        // 파고 들으려면 파고 들고 아니면 말어 // 그런데 이건 2차원만 됨.
        // if ( a && a[Symbol.iterator]) for ( const b of a ) yield b;
        if ( a && a[Symbol.iterator]) yield *a;
        else yield a;
    }
}

go( 
    arr,
    L.flat,
    L.filter(a => a % 2),
    L.map(a => a * a),
    take(2),
    reduce(add),
    log
)

</script>


### 유저목록

<script>
console.clear()

var users = [
    { name : 'a', age: 21, family : [
        { name: 'a1', age: 53 }, { name: 'a2', age: 47 },
        { name: 'a3', age: 16 }, { name: 'a4', age: 14 },
    ] },
    { name : 'b', age: 24, family : [
        { name: 'b1', age: 58 }, { name: 'b2', age: 53 },
        { name: 'b3', age: 10 }, { name: 'b4', age: 22 },
    ] },
    { name : 'c', age: 31, family : [
        { name: 'c1', age: 63 }, { name: 'c2', age: 62 },
    ] },
    { name : 'd', age: 19, family : [
        { name: 'd1', age: 42 }, { name: 'd2', age: 44 },
        { name: 'd3', age: 11 }, { name: 'd4', age: 5 },
    ] }
]

go( 
    users,
    //L.map(u => u.family),
    //L.flat,
    L.filter(u => u.age > 20),
    L.map(u => u.age),
    take(2),
    reduce(add),
//    L.map(a => a * a),
//    reduce(add),
   log
)

console.clear();
</script>



































</body>
</html>